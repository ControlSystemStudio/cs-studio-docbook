<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="ch_products">
<title>Products</title>

<para>This chapter describes how and why Plug-ins get combined into a Product.
</para>

<para>As already explained in <xref linkend="sec_rcp"/>,
a product combines selected Plug-ins with configuration files
and an OS-specific launcher.
</para>
<para>There are several CSS products:
Archive Engine, Archive Config Tool,
Alarm Server, Alarm Config Tool are all examples
for CSS products.
When we talk about
<emphasis role="strong">The CSS Product</emphasis><indexterm><primary>CSS Product</primary></indexterm>,
however, we usually refer to the CSS user interface product
that the end users see.
A product that is just called <code>css</code> or maybe <code>css-xyz</code> because it has
been pre-configured for users at an institute called XYZ.
A product that includes Probe, Data Browser,
maybe the alarm table and tree displays.
</para>
<para>Why is there more than one CSS product?
Why can it be difficult to select the required Plug-ins?
</para>

<figure xml:id="fig_product">  <title>Composition of a Product</title>
  <mediaobject>
    <imageobject><imagedata fileref="product.png" width="100%" format="PNG"/></imageobject>
  </mediaobject>
</figure>

<sect1> <title>Site-Specific Plugin Selection and Settings</title>
<para>Plug-in contain the Java code and associated content like online help
for some CSS functionality.
One example would be a <code>databrowser</code> Plug-in that implements
the Data Browser.
System integrators at different site might prefer some Plug-ins over others,
for example one operator interface tool over another.
</para>

<para>A product is a collection of plugins.
A product definition file can in fact directly list the desired plugins.
In practice, however, plugins are usually first combined into Features,
and the product is then assembled from these features.
Features allow grouping of plugins by functionality.
This way it is easier to add or remove a certain functionality
from the product.
For example, an <quote>optional</quote> feature can list plugins
that are not needed by every user of a product.
When building the product, such an optional feature may be
excluded from the product, but it is made available in an online
update repository. Users who down-load the product can then add
the optional feature as desired.
</para>
<para>Products also contains the default settings, the
<filename>plugin_customization.ini</filename> file described
in <xref linkend="ch_preferences"/>.
To users of CSS it is most convenient when the suitable settings
for their site, for example EPICS Channel Access addresses, web links,
LDAP server hosts for authentication are already <quote>built in</quote>,
so that there is usually no need to adjust any preference settings
after installing CSS onto their office computer.
</para>

<para>To provide a site-specific selection of products with suitable
default settings, most sites will need a custom-built CSS product.</para>

<para>CSS instances can self-update from a repository.
Users will see a notice that updates are available, and CSS will
restart after installing them.
In an operational setup it is typically of advantage to control
which updates become available when and how, which means that each
site that uses CSS will need its own, local update server
from which its CSS instances pull updates that apply to their local CSS
product.
</para>
</sect1>

<sect1> <title>Plug-in Dependencies<indexterm><primary>Dependencies, direct and hidden</primary></indexterm></title>
<para>
A plug-in can depend on other plug-ins.
For example, a data plotting plug-in depends on others
which provide access to archived data, to live data, and it also depends on
a plotting plugin.
When adding a plotting plugin to a product, such direct dependencies are obvious
and Eclipse can help to add them to the product.
There are, however, additional dependencies that Eclipse cannot automatically determine.
</para>

<para>For example, the plug-in on which the plotting tool directly depends to read archived data
only defines the programming interface for reading historic data.
CSS is designed to support multiple sources of archived data,
for example the XML-RPC network data server of the Channel Archiver but also
an RDB-based archive. Some sites use the former, others the latter, some might use both
and other sites might use an entirely different archive data store.
Similar examples exist for access to an electronic log-book, or to reading live control system data.
</para>

<para>Eclipse cannot automatically decide which implementing plug-in are necessary at
a site, so it is up to the creator of a CSS product to select among the available
plug-ins that implement access to archived data, a log book or live data.
She might even need to implement a new, site-specific way of reading historic data
or writing to a log book.
</para>
</sect1>


<sect1> <title>Features<indexterm><primary>Features</primary></indexterm></title>
<para>As just described, we often need more than one plug-in to provide
a certain functionality, for example the <code>databrowser</code> plug-in
with its immediate dependencies combined with a site-specific selection of
log book, live and historic data implementations.
Directly listing all plug-ins in a product configuration would result in
a long list that is hard to maintain.
</para>

<para>A feature is simply a list of related plug-ins, for example all plug-ins
that a site uses for the Data Browser functionality.
Features can also be used to modularize the head-less built,
and features can appear as separate, optional components in an update repository,
allowing end users to install them into their CSS product on demand.
</para>
</sect1>


<sect1> <title>Creating a Product<indexterm><primary>Product, Creating</primary></indexterm></title>
<para>Fundamentally, an RCP Product is a plugin that implements the
<code>org.eclipse.core.runtime.applications</code> extension point,
and has a <filename>*.product</filename> file.
The application extension point represents the <quote>main</quote> routine
of the program, and the product file lists all plugins that you want to include
in your product.
</para>

<para>A CSS application should create a workbench window with certain menus
into which other CSS plugins can then add their entries. Similarly, it needs
to create a skeleton for the online help and preference system.
Existing CSS plugins can be used to provide these.
</para>

<sect2>  <title>New Product Plug-in</title>
<para>Create a new plugin. The suggested name is <code>org.csstudio.</code>
followed by your site name and ending in <code>.product</code>,
for example <code>org.csstudio.mysite.product</code>.
</para>
<para>Add these dependencies:
</para>
<variablelist>
  <varlistentry><term><code>org.eclipse.core.runtime</code></term>
  <listitem>Defines the application extension point.</listitem>
  </varlistentry>

  <varlistentry><term><code>org.eclipse.ui.intro</code>,
   <code>org.eclipse.ui.intro.universal</code></term>
  <listitem>Will later be used to implement the <quote>Welcome</quote> screen.</listitem>
  </varlistentry>

  <varlistentry><term><code>org.csstudio.startup</code></term>
  <listitem>Provides basic CSS-compliant application code.</listitem>
  </varlistentry>

  <varlistentry><term><code>org.csstudio.utility.product</code></term>
  <listitem>Provides extensions to the basic CSS-compliant application code.</listitem>
  </varlistentry>
</variablelist>

<para>Fundamentally, the application code of an RCP product
is allowed to do pretty much anything.
CSS end-user products, however, are expected to have
a main window, a menu bar as described in <xref linkend="ch_menues"/>,
and support for online help.
A CSS product should support opening documents from the command line,
see <xref linkend="ch_openfile"/>.
To simplify the creation of a compliant product,
the <code>org.csstudio.startup</code> plugin provides
the essential application code and extension points for
customizing it according to local needs.
Commonly used implementations of these extension points
in turn are provided by the plugin
<code>org.csstudio.utility.product</code>.
Using these two plugins, a site-specific product can
often be created without having to implement any
application code.
</para>
</sect2>

<sect2>  <title>Implement Application</title>
<para>In the new product plugin, extend the <code>org.eclipse.core.runtime.applications</code>
extension point.
As an ID, you can simply enter <quote>application</quote> which will result
in a complete ID of <code>org.csstudio.mysite.product.application</code>.
Add a <quote>run</quote> element with value
<code>org.csstudio.startup.application.Application</code>,
i.e. use the skeleton implementation from the CSS startup plugin.
</para>

<para>The plugin <code>org.csstudio.startup</code>
defines an extension point for customizing the behavior
of its application code.
In the new product plugin, extend this point which is called
<code>org.csstudio.startup.module</code>
and add parameters to it so that the corresponding section of
your <filename>plugin.xml</filename> file looks as follows:
</para>
<programlisting><![CDATA[<extension point="org.csstudio.startup.module">
  <startupParameters
    class="org.csstudio.utility.product.StartupParameters">
  </startupParameters>
  <project
    class="org.csstudio.startup.module.defaults.DefaultProject">
  </project>
  <workbench
    class="org.csstudio.utility.product.Workbench">
  </workbench>
</extension>]]>
</programlisting>

<para>The startup parameters code will parse command-line parameters.
The default project code asserts that your product has at
least one <quote>CSS</quote> project in its workspace.
The workbench code, finally, is the most important part: It
opens the window, configures it, and executes the main loop
of the RCP application.
</para>
</sect2>

<sect2>  <title>Add Product Definition</title>
<para>Use the IDE wizard to create a new <quote>Plug-in Development</quote>,
<quote>Product Configuration</quote> in your product plugin.
When editing the generated <filename>.product</filename> file,
one of the first things you can set in the <quote>General Information</quote>
section of the <quote>Overview</quote> tab of the product editor
is the Name of your product.
You should use <quote>Css</quote> as the name, for an explanation
see <xref linkend="ch_openfile"/>.
</para>
<para>Select the application ID defined in the previous step.
Press the <quote>New...</quote> button next to the <quote>Product Definition</quote>
section to create a new product ID, and in there again select your application ID.
</para>
<para>Next you need to select if your product configuration is based on plugins or features,
and then list either plugin or features in the <quote>Dependencies</quote> tab.
Initially it is easier to base a product on plugins.
You can list the application plugins that you want to include in your product,
for example Probe and BOY. You then press the <quote>Add Required Plug-ins</quote>
button, and you are done.
</para>
<para>This approach has the disadvantage that your product consists of a long
list of plugins. After the fact it will be hard to determine which plugins you wanted to include
in your product to provide the user with some functionality, and which plugins had
to be added because they were dependencies of those functional plugins.
Also remember that you might need plugins that do not show up as direct dependencies.
</para>
<para>In the long run your product might be easier to maintain if it is based on features.
You define one feature to list the application plugins that you want for your users,
and separate features to list the plugins that result from dependencies,
maybe further separated into CSS core plugins and those from Eclipse.
The following describes how to create those features.
</para>
</sect2>

<sect2>  <title>Create <code>applications</code> Feature</title>
<para>Create a new <quote>Feature</quote> project called
<code>org.csstudio.mysite.applications.feature</code>.
This feature lists all the application plugins that you want to
include into your product, for example the plugins for Probe,
Data Browser, BOY.
</para>
<para>Start by adding your product plugin, then add the application
plugins. Some application plugins are already pre-aggregated into
features, for example
<code>org.csstudio.opibuilder.feature</code>.
You can add individual plugins or make your applications feature
include other features.
</para>
<para>Add the <code>applications</code> feature as a dependency to your
<filename>*.product</filename>.
</para>
</sect2>

<sect2>  <title>Create <code>core</code> Feature</title>
<para>Similar to the <code>eclipse</code> feature, create a feature
called <code>org.csstudio.mysite.core.feature</code> and add it as
a dependency to your product.
This feature will list all <quote>core</quote> CSS plugins that your application
plugins need.
By separating these supporting plugins from the application plugins that
the end user sees, it will be easier to maintain your product in the long run.
</para>
<para>Some plugin that you will have to add:
</para>
<itemizedlist>
<listitem> <code>org.csstudio.startup</code> - Required by our product</listitem>
<listitem> <code>org.csstudio.utility.product</code> - ditto</listitem>
<listitem> <code>org.csstudio.ui.menu</code> - Define CSS menu structure</listitem>
<listitem> <code>org.csstudio.ui.help</code> - Define CSS help structure</listitem>
</itemizedlist>

<para>We will soon add more core plugins.
Add the <code>core</code> feature as a dependency to your <filename>*.product</filename>.
</para>
</sect2>

<sect2>  <title>Create <code>eclipse</code> Feature</title>
<para>Finally, create an <code>eclipse</code> feature.
This feature will list all Eclipse plugins, i.e. plugins that CSS uses but
which are provided by Eclipse.
It is unfortunately not very easy to determine which Eclipse plugins you
need to include in your product, and details will change between versions
of Eclipse.
For this reason it is useful to list them in their own feature.
</para>
<para>Start by adding <code>org.eclipse.core.runtime</code> to your
<code>eclipse</code> feature, then add the <code>eclipse</code> feature
as a dependency to your <filename>*.product</filename>.
</para>
</sect2>


<sect2>  <title>Fix Dependencies<indexterm><primary>Dependency Errors, Fixing</primary></indexterm></title>
<para>When a product is based on features, some manual labor will
be required to add direct plugin dependencies to the 
<code>core</code> respectively <code>eclipse</code> features.
</para>
<para>Start by trying to run the new product from within the IDE:
Open the <filename>*.product</filename> file, press <quote>Synchronize</quote>
and then <quote>Launch an Eclipse Application</quote>.
Your product will <emphasis>not</emphasis> start.
Instead, you will see many error messages, including
<quote>The application could not start. Would you like to view the log?</quote>.
When you select to see the errors in an Error log view, which is typically more convenient,
or in a plain log file that looks like this:

<programlisting>!MESSAGE Bundle .../org.csstudio.ui.help/ was not resolved.
!MESSAGE Missing required bundle org.eclipse.help.ui_0.0.0
</programlisting>

This means that the plugin <code>org.eclipse.help.ui</code> is a missing direct dependency
of your product. Add all missing plugins with names starting in org.csstudio into your
<code>core</code> feature, and add the missing Eclipse plugins into your <code>eclipse</code>
feature.
</para>
<para>For some missing dependencies you will find that they are available
in system-specific variants<indexterm><primary>Operating-system specific plugins</primary></indexterm>.
One example is file system access, which includes
plugins <code>org.eclipse.core.filesystem.win32.x86</code>
and <code>org.eclipse.core.filesystem.macosx</code> because details of file
systems differ between operating systems.
You should go ahead and add all variants, because eventually you want to build
your product for multiple architectures.
When doing this, however, you should configure the feature to only include
those plugins on the appropriate target architecture.
In the feature editor, you can enter the operating systems and architecture for each
plugin. In the generated <filename>feature.xml</filename> file, it should look like this:
<programlisting><![CDATA[<plugin
   id="org.eclipse.core.filesystem.win32.x86"
   os="win32"
   arch="x86"
   ...]]>
</programlisting> 
</para>

<figure xml:id="fig_prod_validate">  <title>Plug-in Dependency Validator</title>
  <mediaobject>
    <imageobject><imagedata fileref="validate.png" width="40%" format="PNG"/></imageobject>
  </mediaobject>
</figure>

<para>Another display of missing plugin dependencies<indexterm><primary>Plug-in Dependency Validation</primary></indexterm>
is available from the menu <quote>Run</quote>, <quote>Run Configurations...</quote>.
Locate the Eclipse Application entry for your product,
select the <quote>Plug-ins</quote> tab and press the
<quote>Validate Plug-Ins</quote> button.
It will open a display of missing dependencies as shown in
<xref linkend="fig_prod_validate"/>.
</para>

<para>Continue to add missing dependencies to your features,
occasionally pressing <quote>Synchronize</quote> and then <quote>Launch an Eclipse Application</quote>
in your product to see which dependencies are still required.
</para>
</sect2>

</sect1>

</chapter>
