<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap_alarm">
<title>Alarm System</title>

<para>This chapter introduces the CSS alarm system, specifically the
<quote>Best Ever Alarm System Toolkit</quote> or BEAST<indexterm><primary>BEAST</primary></indexterm>.
It was developed based on experience with the original EPICS alarm handler ALH
combined with ideas from the book
<citetitle pubwork="book">Alarm Management: Seven Effective Methods for Optimum Performance</citetitle>
by B. Hollifield and E. Habibi, published by ISA in 2007.
</para>


<sect1> <title>Motivation</title>
<para>The primary goal of the alarm system is simple:</para>

<blockquote>
<emphasis>Effectively help operators take the correct action at the correct time.</emphasis>
</blockquote>

<para>This is easier said than done!
One way to accomplish this is to adopt the following guiding principles
for an alarm handling philosophy:
</para>

<itemizedlist>
<listitem>
<para>Alarms are presented with guidance, related displays.</para>
<para>Lacking these, how can operators effectively react to an alarm?</para>
</listitem>
<listitem>
<para>Manageable alarm rate</para>
<para>The number of alarms should stay below about 150 per day.
If the alarm rate gets much higher, the alarm system will no longer help operators
take correct actions but instead overload them with information.
</para>
</listitem>
<listitem>
<para>Operators will respond to every alarm.</para>
<para>This is a corollary to the previous item:
Assuming a manageable alarm rate, operators are expected to
respond to each alarm.
</para>
</listitem>
</itemizedlist>

<para>To implement such an alarm handling philosophy, a lot of
effort needs to be put into defining useful alarms.
Each alarm must have guidance, clearly describing what operators
need to <emphasis>do</emphasis> in response to an alarm.
There should not be any <quote>bogus</quote> alarms from systems
that undergo maintenance,
or that are currently irrelevant for the operation of the machine.
Alarms must not <quote>chatter</quote>, causing unnecessary noise by
going in and out of alarm.
Operators need convenient access to the currently active alarms and
their associated information.
The alarm system tools described in the following try to help:
</para>

<itemizedlist>
<listitem>Alarms are presented in user-selectable ways:
Table of current alarms, sorted as desired,
but also a tree-view, displaying all or only active alarms.
In principle, additional views can be added.
</listitem>
<listitem>Each alarm is presented with additional information like guidance on how to handle
the alarm. There are links to related operator screens, web pages, and other CSS tools.
</listitem>
<listitem>The alarm system configuration can be edited from within the alarm system user interface.
</listitem>
</itemizedlist>
</sect1>


<sect1> <title>Alarm Trigger PVs</title>
<para>The alarm system handles the display of alarms and associated information.
The triggers<indexterm><primary>Alarm Trigger PV</primary></indexterm>
of alarms are simply Process Variables (PVs) in the control system,
outside of the alarm system per se.
The alarm system monitors such PVs, and a non-normal severity
will trigger an alarm.
</para>
<para>In some cases, existing control system PVs that already have
suitable limits can be used as trigger PVs for the alarm system.
In other cases, new PVs may have to be created to serve as alarm trigger PVs.
For EPICS, this can be done on IOCs associated with the respective subsystem
of the machine, or in soft IOCs that are purely meant to serve alarm trigger PVs.
In any case, alarm trigger PVs must generate a non-normal severity like
<quote>MINOR</quote> or <quote>MAJOR</quote> to trigger an alarm.
</para>
</sect1>


<sect1> <title>Alarm System Behavior</title>
<para>The alarm system will typically
<emphasis>latch</emphasis> alarms<indexterm><primary>Latching Alarm</primary></indexterm>.
This means that the alarm trigger PV can return to OK, later re-enter
the alarm state and so on, but the alarm system will only react when a PV enters
an alarm state for the first time. Subsequently, the alarm system user
interface will display the current state of the PV, but it will not
trigger a new alarm nor issue another annunciation.
This is meant to reduce noise from the alarm system.
</para>
<para>Once operators are able to react to the original alarm,
operators <emphasis>acknowledge</emphasis><indexterm><primary>Acknowledge Alarm</primary></indexterm>
the alarm,
and the alarm trigger PV returns to normal,
the alarm will <emphasis>clear</emphasis>.<indexterm><primary>Clear Alarm</primary></indexterm>
This is a typical time line:
</para>
<orderedlist>
<listitem>Alarm trigger PV X enters an alarm state, for example with <quote>MINOR</quote> severity.</listitem>
<listitem>The alarm system will indicate a new MINOR alarm for PV X.
If configured to do so, it will also perform a voice annunciation of the alarm.</listitem>
<listitem>In a perfect world, the PV will stay in alarm until the underlying problem
has been handled. In reality, the PV may briefly leave the alarm state,
for example as a result of noise in a sensor.
The alarm system will indicate this, but it still shows that there was a MINOR alarm
with the time when it originally happened.
As the PV re-enters a MINOR severity, there is no new alarm annunciation because
this is considered part of the original alarm that has not been handled, yet.
</listitem>
<listitem>Hopefully, operators can address the underlying issue soon, the alarm trigger PV
returns to a normal severity, and operators acknowledge the alarm.
</listitem>
<listitem>The alarm clears.
It does not matter if the PV returns to normal, then operators acknowledge the alarm,
or operators first acknowledge the alarm, then the PV returns to normal.
The alarm will clear as soon as both conditions are met: PV returns to normal, alarm has been acknowledged.
</listitem>
</orderedlist>

<para>Alarms may be configured not to latch,<indexterm><primary>Non-Latching Alarms</primary></indexterm>
which means there is no need to acknowledge them.
As soon as the alarm trigger PV returns to normal, the alarm will also clear.
This mode of operation is primarily meant for alarm trigger PVs that already latch
within the control system.
An example would be an alarm trigger PV related to the <quote>trip</quote>
condition of a device that requires a manual reset by operators to clear.
That manual reset of the device is functionally equivalent to acknowledging the alarm,
because an operator has noticed the condition and taken corrective action.
The alarm trigger PV is unlikely to chatter because it latches until the device is reset.
Requiring operators to acknowledge the alarm in addition to resetting the alarm trigger PV
would cause unnecessary work.
</para>

<para>One might be tempted to configure frequent alarms as non-latching
to lessen the load on operators who get tired of acknowledging such
a nuisance alarm.<indexterm><primary>Nuisance Alarm</primary></indexterm>
Overall, however, it is better to re-engineer such alarms.
Add a filter to avoid alarms from brief occurrences of the symptom.
Find a way to alarm on a precursor of the frequent alarm,
allowing operators to avoid running the machine in a state that
will later cause frequent occurrences of the nuisance alarm.
Ideally, fix the underlying hardware or software to avoid the nuisance alarm altogether.
</para>
</sect1>


<sect1> <title>Technical Overview</title>
<figure xml:id="fig_beast">  <title>Alarm System Overview</title>
  <mediaobject>
    <imageobject><imagedata fileref="beast.png" width="100%" format="PNG"/></imageobject>
  </mediaobject>
</figure>
<para>Fundamental to the operation of the alarm system is the
<code>AlarmServer</code><indexterm><primary>AlarmServer</primary></indexterm>.
It reads the alarm system configuration from a relational database
and monitors alarm system trigger PVs.
Whenever a new alarm occurs, it informs alarm system user interfaces (GUIs)
via JMS. For alarms that should be annunciated, it will inform
annunciation tools via a designated JMS topic.
</para>
<para>The Alarm Server performs the latching alarm behavior described in the previous section.
As the severity of an alarm trigger PV changes, the server updates the GUIs via JMS
about the current state of the PV, but it maintains the latched alarm state.
</para>
<para>When operators acknowledge an alarm in the GUI, they are sending an acknowledge request
via JMS to the Alarm Server. The server will in turn reply with the updated, eventually the cleared
alarm state.
</para>
<para>In addition to sending state updates via JMS, the Alarm Server also updates
the alarm state in the relational database. This is done to allow newly started alarm GUI
clients to obtain the initial state of all alarms. The persisted alarm state in the RDB
also allows for Alarm Server restarts without loosing the alarm state.
</para>
<para>Alarm GUI clients can change the alarm system configuration in the RDB.
They use JMS to notify the Alarm Server and other GUI clients about the change,
who then in turn read the updated configuration from the RDB.
</para>
<para>As described, all alarm traffic passes through JMS:
Alarm state updates, annunciations, acknowledgements, configuration changes.
A generic JMS-to-RDB logger can thus capture all alarm traffic into an RDB
for later review and anaysis, for example: What happened when? Which alarm was most frequent? 
</para>

<sect2> <title>Alarm Tree <quote>Root</quote></title>
<para>The RDB can hold more than one alarm system configuration.
Each alarm configuration is identified by the name of its
<quote>Root</quote><indexterm><primary>Alarm Tree Root</primary></indexterm>
element, for example CCR for a Central Control Room configuration.
</para>
<para>The Alarm Server and associated user interface clients must use
the same alarm tree root.
They will construct the names of JMS topics<indexterm><primary>Alarm System JMS Topics</primary></indexterm>
used to communicate by adding suffixes to the alarm tree root name.
For example, with an alarm tree root of CCR, the server and clients
will use the following JMS topics:
</para>
<itemizedlist>
<listitem>CCR_SERVER:
Used by the server to send alarm state updates to clients.
</listitem>
<listitem>CCR_CLIENT:
Used by clients to send acknowledgement requests or configuration change notifications
to the server.
</listitem>
<listitem>CCR_TALK:
Used by the server to send annunciation messages to annunciators.
</listitem>
</itemizedlist>
</sect2>

<sect2> <title>Multiple Parallel Alarm Configurations</title>
<para>Exactly one alarm server needs to be running for each alarm system configuration,
i.e. for each alarm tree root.
Clients are bound to a specific alarm configuration via
a preference setting that selects their alarm tree root name.
Optionally, it is possible to enable users to change the alarm configuration
at runtime via a selector in the Alarm Tree display.
</para>
</sect2>

<sect2> <title><quote>Global</quote> Alarms</title>
<para>
  <emphasis>The following is under development, not in operational use:</emphasis>
</para>
<para>An alarm server can send information about alarms that stay un-acknowledged for
a configurable time to a <quote>GLOBAL_SERVER</quote> alarm topic in JMS.
A corresponding global alarm table user interface can display such alarms
and allow operators to quickly switch to that alarm system configuration,
where they then have access to the alarms guidance etc.
</para>
<para>The use case for this is a central control room combined with
several auxiliary, sub-system-specific control rooms. For example
a cryogenic or conventional facility control room in addition to a
bigger <quote>main</quote> control room.
Most of the time, the auxiliary control rooms use their own alarm
system configuration, specific to their needs, and all alarms
are handled locally.
</para>
<para>At night or on weekends, however, the auxiliary control rooms
are not manned. At those times, alarms are not locally acknowledged,
and after some timeout they will appear in the global alarm table
of the main control room.
</para>
<para>A listener to JMS messages on the GLOBAL_SERVER topic can also
be used to trigger automated email notifications or send
cell phone text messages in response to unhandled, i.e. un-acknowledged
global alarms.
</para>
</sect2>
</sect1>


<sect1>  <title>Relational Database Setup</title>
<para>Before using the alarm system tools, you need to create the required table structure in your RDB,
see also <xref linkend="ch_rdb"/>.
Refer to the sources for the plugin <code>org.csstudio.alarm.beast</code>.
Its <filename>dbd</filename> subdirectory contains
schema definitions for MySQL, Oracle and PostgreSQL.
Pick the file that is appropriate for your RDB, and execute the commands listed in the file.
</para>
<para>When done, you should have the alarm tables defined in your RDB.
You have to use basic RDB administration skills to create a user and password for
an account that the alarm tools can use to read and modify the alarm system configuration.
</para>
</sect1>


<sect1>  <title>Building the Tools</title>
<para>You need these command-line tools:
<programlisting>org.csstudio.alarm.beast.configtool/AlarmConfigTool.product
org.csstudio.alarm.beast.server/AlarmServer.product
</programlisting>
</para>
<para>For first tests, you can run both tools from within the Eclipse IDE as described in
<xref linkend="chap_compiling"/>, <xref linkend="sec_runnning_in_ide"/>,
but note that you will have to provide command-line arguments to them.
After first tests are successful, you can export them from the IDE as described in the same section.
</para>
<para>Finally, you will need to include the alarm system client GUI (Alarm Table, Alarm Tree, Annunciator)
into your end-user CSS product.
</para>
</sect1>


<sect1>  <title>Authentication and Authorization</title>
<para>The Alarm Config Tool and the Alarm Server obviously
need an account with write access to the alarm tables in the RDB
because they modify the alarm configuration or state.
</para>
<para>The alarm client GUI (Alarm Table, ...) is primiarily read-only,
so a corresponding read-only RDB account would be sufficient.
The GUI does, however, use CSS CSS authentication and authorization
to allow a user to <quote>Log On</quote>, and qualified users
are then permitted to modify the alarm configuration.
It is in fact a prime feature of the alarm system that selected users
can modify the alarm configuration on-line.
For this to function, the CSS alarm GUI acutally
requires an RDB account with write access.
The <emphasis>CSS alarm GUI should therefore be provided with a write-access RDB account</emphasis>,
and CSS authentication and authorization is then used to limit the use
of that account within CSS.
</para>
<para>The alarm GUI uses these Authorization IDs:
</para>
<itemizedlist>
<listitem><code>alarm_ack</code> -
Users with this authorization can acknowledge alarms.
</listitem>
<listitem><code>alarm_config</code> -
Users with this authorization can edit the alarm system configuration.
</listitem>
</itemizedlist>

<para>For initial tests, you can configure CSS authentication and authorization
to use a <quote>dummy</quote> mode where every user can authenticate and gain these rights.
Eventually, however, you might want to configure proper authentication and authorization.
Refer to <xref linkend="chap_auth"/> for details.
</para>
</sect1>


<sect1>  <title>Alarm System Preferences</title>
<para>Most of the alarm system related preference settings
are explained and listed with their defaults in the file
<filename>preferences.ini</filename> of the plugin
<code>org.csstudio.alarm.beast</code>.
You will have to adjust the following, most important settings settings
for your site:
</para>
<itemizedlist>
<listitem>URL, user, password and schema for connecting to the RDB
that holds your alarm configuration.
See <xref linkend="ch_rdb_url_and_schema"/>.
</listitem>
<listitem>URL of your JMS server.</listitem>
<listitem>Name of your alarm tree <quote>Root</quote>.</listitem>
</itemizedlist>

<para>This is typically done by adding the site-specific settings
to the <filename>plugin_customization.ini</filename> file of
your product, see <xref linkend="ch_preferences"/>.
For command-line tools like the alarm config tool you can also
create a file <filename>settings.ini</filename> as mentioned below.
</para>
</sect1>


<sect1>  <title>Creating New Alarm Configuration</title>
<para>Each alarm setup starts with a new, empty configuration in the RDB.
The CSS alarm user interface will then allow to edit that configuration,
but the initial, empty configuaration needs to be created in the RDB.
</para>
<para>One way to create a new configuration is an SQL shell.
Assume you want to create a configuration called <quote>demo</quote>,
first check that it does not already exist:
</para>
<programlisting>SELECT * FROM ALARM_TREE
  WHERE NAME='demo' AND PARENT_CMPNT_ID IS NULL;
</programlisting>
<para>Find the next available component ID:
</para>
<programlisting>SELECT MAX(COMPONENT_ID) FROM ALARM_TREE;
</programlisting>
<para>Then create a new alarm tree root like this,
remembering to use the <emphasis role="strong">next</emphasis>
available component ID:
</para>
<programlisting>INSERT INTO ALARM_TREE (NAME, COMPONENT_ID)
VALUES ('demo', 1021);
</programlisting>

<para>While such direct SQL manipulations will work, it may be easier to
use the <code>AlarmConfigTool</code>.
The Alarm Config Tool can import alarm configurations from an XML file format.
A minimal, empty configuration with name <quote>demo</quote> would look like this,
usually saved to a file called <filename>demo.xml</filename>:
</para>
<programlisting><![CDATA[<config name="demo">
</config>
]]></programlisting>

<para>Import such a configuration file into the RDB like this,
assuming that you have a file <filename>settings.ini</filename>
that holds your site-specific RDB connection parameters:
</para>
<programlisting><![CDATA[AlarmConfigTool -pluginCustomization /path/to/my/settings.ini \
-import -root demo -file demo.xml
]]></programlisting>

<para>The config tool has more command-line options to list available configurations
or to export a configuration to a file:
</para>
<programlisting><![CDATA[# Display all parameters
AlarmConfigTool -help

# List alarm tree root names
AlarmConfigTool -list

# Export alarm configuration to XML file
AlarmConfigTool -export -root demo -file demo.xml
]]></programlisting>

<para>While it is usually most convenient to edit an alarm configuration from the
alarm client user interface, bigger changes to the alarm configuration are
sometimes easier by exporting the existing configuration to an XML file,
editing it, then re-importing it. 
</para>
<para>The sources for the plugin <code>org.csstudio.alarm.beast.configtool</code>
contain a schema file for the alarm configuration XML file format,
<filename>AlarmConfigurationSchema.xsd</filename>.
This can be used as a reference or to check an alarm configuration XML file
with XML tool before importing it via the alarm config tool.
</para>
</sect1>


<sect1>  <title>Putting it all together</title>
<para>So far, we described the alarm system in general as
well as the setup of its infrastructure.
In the following sections, we will describe how to run the
alarm server and how to use the alarm client GUI.
</para>
<para>Since this is a distributed system, it is important to
remember its components:
</para>

<itemizedlist>
<listitem>Control System: Often overlooked when you create your first
alarm system test setup, you need for example an EPICS soft IOC that
creates alarms.
</listitem>
<listitem>Configuration in RDB: Previous sections described the RDB table
setup and how to use the Alarm Config Tool to create an initial alarm system configuration.
</listitem>
<listitem>JMS Server: See <xref linkend="ch_jms"/> how to start JMS.
The Alarm Server and the Alarm GUI need to be configured with the URL
of your JMS server to communicate.
</listitem>
<listitem>Alarm Server: Its operation will be described in the following sections.
</listitem>
<listitem>CSS Alarm GUI: Your CSS product needs to include the alarm tree and alarm table
plugins to allow access to the alarm system.
In addition, at least <quote>dummy</quote> authentication and authorization
needs to be configured to permit changes to the alarm configuration from the client GUI.
See <xref linkend="chap_auth"/>.
</listitem>
</itemizedlist>
</sect1>


<sect1>  <title>Alarm Server</title>
<para>The Alarm Server reads an alarm configuration, monitors the PVs of that configuration
and notifies alarm clients about changes in the alarm state.
It persists the alarm state in the RDB. For example, information about latched alarms
is written to the RDB. When the Alarm Server is stopped and re-started, it will
initialize from the RDB and learn about the previous state of all alarms.
This way a previously latched alarm is recognized and not reported as a new alarm.
</para>
<para>The Alarm Server is a command-line tool that is configured via Eclipse preferences,
i.e. usually via a customization file like this:
</para>
<programlisting>AlarmServer -consoleLog -pluginCustomization /path/to/alarm_server.ini
</programlisting>

<para>The alarm server plugin <code>org.csstudio.alarm.beast.server</code>
includes an example plugin customization file <filename>plugin_customization.ini</filename>:
</para>
<programlisting># Alarm System 'root', i.e. configuration name
org.csstudio.alarm.beast/root_component=Annunciator

# Alarm System RDB Connection
org.csstudio.alarm.beast/rdb_url=jdbc:mysql://localhost/alarm
org.csstudio.alarm.beast/rdb_user=alarm
org.csstudio.alarm.beast/rdb_password=$alarm
org.csstudio.alarm.beast/rdb_schema=ALARM

# Alarm System JMS Connection
org.csstudio.alarm.beast/jms_url=failover:(tcp://localhost:61616)
org.csstudio.alarm.beast/jms_user=alarm
org.csstudio.alarm.beast/jms_password=$alarm

# Channel Access
# Network traffic can be optimized by only monitoring ALARM updates
org.csstudio.platform.libs.epics/use_pure_java=false
org.csstudio.platform.libs.epics/monitor=ALARM
org.csstudio.platform.libs.epics/addr_list=127.0.0.1

# Logging preferences
org.csstudio.logging/console_level=CONFIG
org.csstudio.logging/jms_url=
</programlisting>

<para>For more on the Eclipse preference mechanism, see <xref linkend="ch_preferences"/>.
</para>
<para>If you started the Alarm Server successfully, its terminal output should
resemble this, displaying the JMS topics used by the alarm server:
</para>
<programlisting>Alarm Server 3.0.0
Configuration Root: demo
JMS Server Topic:   demo_SERVER
JMS Client Topic:   demo_CLIENT
JMS Talk Topic:     demo_TALK
JMS Global Topic:   GLOBAL_SERVER
Read 50003 PVs in 1.69 seconds: 29589.0 PVs/sec
</programlisting>

<para>The alarm server communicates with the alarm GUI via JMS
messages described in the following section.
The alarm GUI will either show alarm updates, or it will indicate
a server timeout if the alarm server does not communicate.
To debug the setup, the JMS Monitor (<xref linkend="ch_jms_monitor"/>)
can be used to monitor the JMS server, client and talk topics.
The JMS server topic should show alarm state changes or at least
periodic IDLE messages.
</para>
</sect1>


<sect1>  <title>Alarm System JMS Message Types</title>
<para>The Alarm Server sends this type of JMS <code>MapMessage</code>
for alarm state changes:
</para>
<itemizedlist>
<listitem><code>TYPE</code>: Set to <quote>alarm</quote> to identify as alarm message.</listitem>
<listitem><code>TEXT</code>: STATE in normal mode, STATE_MAINTENANCE in maintenance mode.</listitem>
<listitem><code>CONFIG</code>: Name of the alarm configuration, i.e. alarm root.</listitem>
<listitem><code>NAME</code>: PV name that has changed alarm state</listitem>
<listitem><code>CURRENT_SEVERITY</code>: Current severity of the PV.</listitem>
<listitem><code>CURRENT_STATUS</code>: Current status of the PV.</listitem>
<listitem><code>SEVERITY</code>: Alarm severity of the PV.
For latched or acknowledged alarms, this can differ from the current severity.
</listitem>
<listitem><code>STATUS</code>: Alarm status of the PV.</listitem>
<listitem><code>EVENTTIME</code>: Time of the original alarm, i.e. when SEVERITY became active.</listitem>
<listitem><code>APPLICATION_ID</code>: AlarmServer.</listitem>
<listitem><code>HOST</code>: Host name running the alarm server.</listitem>
<listitem><code>USER</code>: Name of user who is running the alarm server.</listitem>
</itemizedlist>

<para>In the absense of alarm state changes, the Alarm Server sends
an IDLE message, by default every 10 seconds.
If the alarm client GUI does not see any message from the alarm server
for twice the IDLE period, it declares a server timeout.
</para>
<itemizedlist>
<listitem><code>TYPE</code>: Set to <quote>alarm</quote> to identify as alarm message.</listitem>
<listitem><code>TEXT</code>: IDLE in normal mode, IDLE_MAINTENANCE in maintenance mode.</listitem>
<listitem><code>CONFIG</code>: Name of the alarm configuration, i.e. alarm root.</listitem>
<listitem><code>APPLICATION_ID</code>: AlarmServer.</listitem>
<listitem><code>HOST</code>: Host name running the alarm server.</listitem>
<listitem><code>USER</code>: Name of user who is running the alarm server.</listitem>
</itemizedlist>

<para>Alarm clients send this message to acknowledge
or un-acknowledge an alarm:
</para>
<itemizedlist>
<listitem><code>TYPE</code>: Set to <quote>alarm</quote> to identify as alarm message.</listitem>
<listitem><code>TEXT</code>: ACK respectively UN-ACK.</listitem>
<listitem><code>CONFIG</code>: Name of the alarm configuration, i.e. alarm root.</listitem>
<listitem><code>NAME</code>: PV name</listitem>
<listitem><code>APPLICATION_ID</code>: CSS.</listitem>
<listitem><code>HOST</code>: Host name running CSS.</listitem>
<listitem><code>USER</code>: Name of user who is running CSS.</listitem>
</itemizedlist>

<para>Alarm clients send this message to enable
or disable maintenance mode:
</para>
<itemizedlist>
<listitem><code>TYPE</code>: Set to <quote>alarm</quote> to identify as alarm message.</listitem>
<listitem><code>TEXT</code>: MODE.</listitem>
<listitem><code>VALUE</code>: MAINTENANCE or NORMAL.</listitem>
<listitem><code>CONFIG</code>: Name of the alarm configuration, i.e. alarm root.</listitem>
<listitem><code>APPLICATION_ID</code>: CSS.</listitem>
<listitem><code>HOST</code>: Host name running CSS.</listitem>
<listitem><code>USER</code>: Name of user who is running CSS.</listitem>
</itemizedlist>

<para>After modifying the alarm configuration, alarm clients
send this message to the server:
</para>
<itemizedlist>
<listitem><code>TYPE</code>: Set to <quote>alarm</quote> to identify as alarm message.</listitem>
<listitem><code>TEXT</code>: CONFIG.</listitem>
<listitem><code>CONFIG</code>: Name of the alarm configuration, i.e. alarm root.</listitem>
<listitem><code>NAME</code>: Path to the modified configuration item.</listitem>
<listitem><code>APPLICATION_ID</code>: CSS.</listitem>
<listitem><code>HOST</code>: Host name running CSS.</listitem>
<listitem><code>USER</code>: Name of user who is running CSS.</listitem>
</itemizedlist>

<para>Note that other clients are also listening to this message,
so the server as well as other clients will react by
updating their configuration from the RDB.
If the path contains a specific configuration item like
<quote>/area/system/subsystem/pv</quote>,
only the configuration for that item needs to be updated
from the RDB.
If the path is empty, a bigger change to the configuration
means that the complete alarm configuration needs to be updated
from the RDB.
</para>
</sect1>


<sect1>  <title>Alarm Tree View</title>
<para>The Alarm Tree<indexterm><primary>Alarm Tree View</primary></indexterm>
display can be opened from the menu
<code>CSS</code>, <code>Alarm</code>, <code>Alarm Tree</code>.
It is the primary display for viewing and configuring the complete
alarm tree.
</para>

<figure xml:id="fig_alarm_tree">  <title>Alarm Tree</title>
  <mediaobject>
    <imageobject><imagedata fileref="AlarmTree.png" width="50%" format="PNG"/></imageobject>
  </mediaobject>
</figure>

<para>The alarm tree displays the hierarchical structure of the alarm system.
Alarms are arranged into
</para>
<itemizedlist>
<listitem>Areas - Top-level elements of the alarm hierarchy.
</listitem>
<listitem>Systems, Subsystems - Below the top-level areas, there can be
multiple levels of systems and subsystems to organize your alarm configuration.
</listitem>
<listitem>PVs - Finally, the alarm trigger PVs generate actual alarms.
</listitem>
</itemizedlist>

<para>It is suggested to use physical areas, because that way the general
localization of an alarm in the machine is obvious.
The systems or subsystems could for example be Vacuum or Cooling,
i.e. again physical systems of your machine.
</para>

<para>When configuring the guidance or related displays of an item in the alarm
configuration, this will affect all entries below the respective item.
For example, when adding a display link to an area, this link will be
available for each system, subsystem and PV below that area.
This way it is easy to assign overview displays for an area,
or add guidance with contact information for a system
to those elements in the alarm tree without need to
duplicate the information for each PV.
</para>

<para>The alarm tree needs to be used to add, rename or remove entries of the alarm configuration.
To operators, the alarm tree can be useful if many alarms are active, because
its hierarchical view can allow operators to identify the affected areas or subsystems
better than a plain list of alarms could do.
</para>

<para>For details on how to use the alarm tree, refer to its online help.
</para>
</sect1>


<sect1>  <title>Alarm Table View</title>
<para>In an ideal operational setup, there are only very few alarms.
If alarms trigger, they may be from very different areas of the machine.
In this scenario, operators are often not interested in all the possible alarms
as they are displayed by the Alarm Tree.
Instead, they only need to know the currently active alarms.
</para>

<figure xml:id="fig_alarm_table">  <title>Alarm Table</title>
  <mediaobject>
    <imageobject><imagedata fileref="AlarmTable.png" width="100%" format="PNG"/></imageobject>
  </mediaobject>
</figure>

<para>The Alarm Table<indexterm><primary>Alarm Table View</primary></indexterm>
display is the primary operator interface to the alarm system
in an operational setup for a machine that is generally running fine.
Most of the time, the alarm table will be empty, because there are no alarms.
If alarms occur, the alarm table allows operators to inspect them quickly.
</para>

<para>For details on how to use the alarm table, refer to its online help.
</para>
</sect1>


<sect1>  <title>Annunciator</title>
<para>To be written...
</para>
</sect1>

<sect1>  <title>JMS Alarm Log</title>
<para>The JMS2RDB tool described in
<xref linkend="ch_org.cstudio.sns.jms2rdb"/>
can be used to log all alarm traffic
to the RDB.
This way, detail of alarm state changes and operator
acknowledge actions will be available in the CSS log
for later analysis.
The message history display
described in <xref linkend="ch_org.cstudio.alarm.beast.msghist"/>
allows direct access to the log, although it can be time consuming
the decode the raw messages.
</para>
<para>At the SNS, a JSP-based collection of reports can display
how many alarms were active over the last days or weeks,
which alarms represent the <quote>Top 10</quote> of the most
frequent alarms, and how one alarm behaved in detail,
including histograms of alarm durations.
</para>
<para>This reporting package, however, is currently part of a bigger,
more SNS-specific reporting package. Contact Kay Kasemir if you
are interested in collaborating on a more portable version of
these reports.
</para>

</sect1>


</chapter>
