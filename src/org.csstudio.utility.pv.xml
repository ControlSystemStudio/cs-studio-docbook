<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
         xml:id="ch_utility.pv">
<title>PV Access - org.csstudio.utility.pv<indexterm><primary>org.csstudio.utility.pv</primary></indexterm></title>

<para>This plugin provides one of the CSS APIs for accessing live control
system data, i.e. read process variable samples from front-end computers.
Its emphasis is on fairly straight-forward access to individual PVs,
using a listener for received updates.
</para>


<sect1> <title>Usage</title>
<para>The <code>org.csstudio.utility.pv</code> plugin defines
the API for accessing PVs, an extension point to implement
such PVs, and a <code>PVFactory</code> to access available
implementations.
</para>
<para>Typical usage looks like this:</para>

<programlisting>// Create PV
final PV pv = PVFactory.createPV(pv_name);
// Register listener for updates
pv.addListener(new PVListener()
{
    public void pvDisconnected(PV pv)
    {
        System.out.println(pv.getName() + " is disconnected");
    }
    public void pvValueUpdate(PV pv)
    {
        IValue value = pv.getValue();
        System.out.println(pv.getName() + " = " + value);
        if (value instanceof IDoubleValue)
        {
            IDoubleValue dbl = (IDoubleValue) value;
            System.out.println(dbl.getValue());
        }
        // ... or use ValueUtil
    }
});
// Start the PV
pv.start();

...

pv.stop();
</programlisting>

<para>The <code>IValue</code>-derived data objects contain
not only a basic value, i.e. number or string,
but also a time stamp, status/severity information
and in most cases meta data<indexterm><primary>Meta Data, PV</primary></indexterm>.
The meta data provides information for display tools:
value range, alarm limits, units, or strings that represent the states
of enumerated PVs.
</para>
</sect1>


<sect1> <title>Available Implementations</title>

<para>The plugin <code>org.csstudio.utility.pv</code> defines an interface
for accessing live control system data.
The archive engine for example uses that library for subscribing to value updates from PVs
that you want to archive.
</para>
<para>The <code>utility.pv</code> plugin does not, however, contain any implementation.
Instead, it defines an Eclipse Extension Point that allows other plugins
to provide pluggable implementations.
</para>
<para>By including either one or all of the following plugins in a product like the archive engine,
one can build an archive engine that supports EPICS,
or EPICS and simulated PVs, or only simulated PVs.
</para>
<para>To associate PVs with an implementation, a prefix is used,
for example
<code>sim://sine</code> for a simulated PV <quote>sine</quote> or
<code>ca://fred</code> for a Channel Access PV <quote>fred</quote>.
The utility.pv plugin has a preference setting to specify a default
prefix, which is usually set to the control system protocol.
In that case, simply specifying a PV name of <code>fred</code>
will also select <code>ca://fred</code>.
</para>


<sect2>  <title>EPICS Channel Access</title>
<para>The plugin
<code>org.csstudio.utility.pv.epics</code><indexterm><primary>org.csstudio.utility.pv.epics</primary></indexterm>
implements live data access based on
EPICS Channel Access<indexterm><primary>Channel Access, EPICS</primary></indexterm>
Version 3.
</para>
<para>Note that the Channel Access settings like the CA server address list
are configured from Eclipse properties defined
in the plugin <code>org.csstudio.platform.libs.epics</code>.
</para>
<para>One important setting is the choice of <quote>pure Java</quote>
or the JNI implementation of JCA<indexterm><primary>JCA</primary></indexterm>.
When selecting the former, the CAJ<indexterm><primary>CAJ</primary></indexterm>
library will be used. CAJ is a pure Java Channel Access client implementation,
usable on all platforms, and generally offering good performance.
Choose JNI if you prefer to use the original Channel Access client library from EPICS base.
The JNI client library guarantees full compatibility with existing EPICS infrastructure,
but requires a system-specific version of the JNI binary.
Refer to the <filename>README.txt</filename> in the libs.epics plugin for
instructions on building this binary.
</para>
<para>The libs.epics settings also include the subscription mode:
<itemizedlist>
<listitem>VALUE - Subscribe to all value changes.
Analog EPICS records can apply an MDEL update threshold.
This is the default mode for CSS.
</listitem>
<listitem>ARCHIVE - Subscribe to archive updates.
For analog EPICS records, this uses the dedicated ADEL update threshold.
This should be used for the ArchiveEngine.
</listitem>
<listitem>ALARM - Subscribe to alarm state/severity changes.
This should be used for the AlarmServer.
</listitem>
</itemizedlist>
</para>
<para>The utility.pv plugin attempts to read the <code>DBR_CTRL_...</code>
meta data for each PV <emphasis>once</emphasis> on connection.
EPICS IOCs will fill the meta data based on certain record
fields like EGU, PREC, HIHI, depending on the record type.
</para>
<para>The PV plugin then subscribes to the <code>DBR_TIME_...</code> type of the channel.
This way the full meta data of the channel is known and can be returned
with each value, while the network traffic for the subscription updates
is reduced to the essential time, status and basic number or string.
This procedure is quite common for EPICS client tool, but has the
disadvantage that runtime changes to the meta data will not be noticed
unless the client disconnects and then re-connects, since the full meta
data is only obtained upon channel connection.
</para>
</sect2>

<sect2>  <title>Simulated Data</title>
<para>The plugin
<code>org.csstudio.utility.pv.simu</code><indexterm><primary>org.csstudio.utility.pv.simu</primary></indexterm>
implements simulated PVs like
</para>
<programlisting>sim://ramp</programlisting>

<para>One purpose of simulated PVs is for testing CSS tools in the absense
of an actual control system.
In an operational setup, <quote>local</quote> PVs like
<code>loc://demo</code> can be useful to communicate
via PVs inside CSS, for example between operator interface
panels inside one instance of CSS.
</para>
<para>Refer to the online help of the plugin
<code>org.csstudio.utility.pvmanager.ui</code>
for the syntax of simulated PVs.
</para>
</sect2>
</sect1>


<sect1> <title>Common Issues</title>

<sect2> <title>Cannot read EPICS PVs</title>
<para>If you built CSS yourself from sources, assert that the EPICS plugins
are included.
Under <code>Help</code>, <code>About...</code>, <code>Installation Details</code>, <code>Plug-Ins</code>
check that the plugins <code>org.csstudio.utility.pv.epics</code>
and <code>org.csstudio.platform.libs.epics</code> are available. 
</para>
<para>Check the EPICS CA address list. Try to access the same PV
with the EPICS <code>caget</code> command-line tool.
Compare the EPICS_CA_ADDR_LIST environment variable used by the
command-line tool with the CSS preference for the address list.
</para>
<para>Try both the CAJ and JNI version of CA.
</para>
</sect2>

<sect2> <title>CA Repeater</title>
<para>Channel Access uses a
<filename>caRepeater</filename><indexterm><primary>caRepeater</primary></indexterm>
to monitor beacons from CA servers.
If you run CSS without a CA repeater, you might see error messages
</para>
<programlisting>failed to start executable - "caRepeater" Cannot find the file
</programlisting>

<para>This error means:
You have not started a CA repeater on the computer where you run CSS.
In practice, CSS will work just fine most of the time.
In case of network errors or IOC reboots, however,
it might not re-connect to some PVs after the network or IOC
problem should have been resolved until you re-open the affected tools.
</para>
<para>In an operational control room setup, you should assert that all computers
launch an instance of the EPICS caRepeater on bootup.
</para>
</sect2>

<sect2> <title>No Implementations in Product</title>
<para>While the modular plug-in approach is very flexible, there can be one disadvantage:
The archive engine code for example only depends on <code>org.csstudio.utility.pv</code>,
the <emphasis>definition</emphasis> of the API for accessing live data.
When bundling the archive engine code into a product, this plugin must be included.
</para>
<para>The <emphasis>implementing</emphasis> plugins like
<code>org.csstudio.utility.pv.epics</code> are optional,
allowing you to build an archive engine that does not interface to EPICS
but another network protocol of your choice.
If you fail to include <emphasis>any</emphasis> implementing plugins,
the product will built without errors but later issue runtime error messages
</para>
<programlisting>No extensions to org.csstudio.utility.pv.pvfactory found
</programlisting>

<para>This error means:
The <code>org.csstudio.utility.pv</code> could not locate any implementation,
no factory classes for creating actual live data PVs.
You need to include at least one implementing plugin like
<code>org.csstudio.utility.pv.epics</code> or
<code>org.csstudio.utility.pv.simu</code>.
</para>
</sect2>

</sect1>
</chapter>
