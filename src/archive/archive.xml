<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap_archive">
<title>Archive System</title>

<para>One part of CSS is the Archive System, specifically the
<quote>Best Ever Archive Toolset, yet (BEAUTY)</quote><indexterm><primary>BEAUTY</primary></indexterm>
that was developed as a replacement for the Channel Archiver.
An Archive Engine takes PV data samples from a front-end computer, for example from EPICS IOCs via Channel Access,
and places them in some data storage, see <xref linkend="fig_archive"/>.
Archive client programs then access historic data samples in that storage.
</para>
<para>As described here, the storage is a
Relational Database (RDB)<indexterm><primary>Relational Database (RDB)</primary></indexterm>
like MySQL, Oracle or PostgreSQL.
Both the historic data of PVs and the Archive Engine configuration are stored in the same relational database.
The engine configuration can be imported from an XML file format into the database, or it can be exported
from the database back into an XML file format for editing.
The archive engine uses a pluggable implementation for its configuration and data storage as
described in <xref linkend="chap_org_csstudio_archive_engine"/>, so it is fundamentally
possible to use the archive engine with different storage for the configuration and data,
but in the following examples we concentrate on an RDB-based setup.
</para>

<para>Typical setups will include more than one Archive Engine, for example one sample engine per subsystem.
In principle, data providers other than archive engines can also write samples to the storage.
The CSS Data Browser is a generic client program for looking at archived data,
but fundamentally any program that has access to a relational database can be used
to create reports. A typical application might be JSP-based web reports of data.
</para>

<figure xml:id="fig_archive">  <title>Archive System Overview</title>
  <mediaobject>
    <imageobject><imagedata fileref="archive.png" width="100%" format="PNG"/></imageobject>
  </mediaobject>
</figure>

<para>There are two integration points with the legacy Channel Archiver<indexterm><primary>Channel Archiver</primary></indexterm>:
The <code>ArchiveConfigTool</code> tool can import existing archive engine configuration files into the RDB because the
XML file format is compatible with the Channel Archiver.
The Data Browser is capable of reading data from the relational database as well as from the Channel Archiver's
XML-RPC-based data server, thereby allowing nearly transparent access to both <quote>old</quote> and <quote>new</quote>
data.
</para>


<sect1>  <title>Building the Tools</title>

<para>The Archive Engine is the central sampling tool that reads values from PVs and writes them to the
archive data storage.
It is implemented as an Eclipse product.
You will probably also want to build ArchiveConfigTool, 
the tool used to import engine configuration files into the relational database.
They are defined in these product files:

<programlisting>org.csstudio.archive.engine/ArchiveEngine.product
org.csstudio.archive.config.rdb/ArchiveConfigTool.product
</programlisting>

For first tests, you can run both tools from within the Eclipse IDE as described in
<xref linkend="chap_compiling"/>, <xref linkend="sec_runnning_in_ide"/>,
but note that you will have to provide command-line arguments to them.
After first tests are successful, you can export them from the IDE as described in the same section.
Finally, you will need one of the CSS end-user products that includes the Data Browser to
look at the archived data, but for now we concentrate on the tools
needed to collect data.
</para>
</sect1>


<sect1 xml:id="sec_archive_rdb_setup">  <title>Relational Database Setup</title>

<para>Before using the archive tools, you need to create the required table structure in your RDB.
Currently MySQL, Oracle and PostgreSQL are supported, see also
<xref linkend="ch_rdb"/>.
</para>

<para>The commands for creating the RDB table structures are in files in the <code>dbd</code> sub-directory
of the plugin <code>org.csstudio.archive.rdb</code>.
Basic RDB administration skills will be required because you need to create the table structure by using one of these files,
and will probably also need to create two accounts: One account for the archive engines that has write access to the tables,
and another read-only account for archive clients like the CSS Data Browser to read archived data.
</para>

<para>The RDB tables for the different database dialects are very similar with the exception of the 
<code>TIMESTAMP</code> used to store the time stamps of samples.
While the Oracle time stamp data type already offers nanosecond detail,
the MySQL and PostgreSQL data types of the same name only cover seconds.
The MySQL tables therefore have an added <code>nanosecs</code> column for this purpose.
There are a few more differences in the SQL dialects, but the Archive Engine and Data Browser
auto-configure based on the database URL.
</para>

<para>The setup for MySQL might be the easiest at least for development and testing, but it has limitations.
All samples for all channels are written to one <code>sample</code> table. By default, MySQL table sizes are limited to 4GB
(See MySQL <code>show table status</code> command, column <quote>Max_data_length</quote>).
While this can be adjusted, I believe there is still a limit of 4G rows (=samples).
Furthermore, while it will be almost trivial to enter something like
<programlisting><![CDATA[DELETE FROM sample WHERE smpl_time < ...
]]></programlisting>
to delete older samples, this will either not free up any space or require an added <code>OPTIMIZE</code> rebuild, which takes a very long time.
</para>

<para>For PostgreSQL, the table size limit at this time seems to be much higher at 32TB, with no additional row count limit.
Performance of the <code>sample</code> table that holds archived samples is reduced by about 50%
when adding constraints. The <code>dbd</code> file for PostgreSQL includes constraints to allow the RDB
to assert referential data integrity, but if you trust the Archive Engine code to only write correct
samples to the RDB, performance can be gained by disabling the <code>sample</code> table constraints. 
</para>

<para>One reason for using Oracle lies in its support for partitioning.
While the sample <code>sample</code> appears as one table,
it can be spread over several table partitions based on the sample time and channel name.
Spreading by channel name might improve performance because several channels can be written
in parallel to different disk locations. Partitioning by time allows quick removal of older samples.
In addition, for Oracle the archive data readout implementation used by the Data Browser
(plugin <code>org.csstudio.archivereader.rdb</code>)
supports a stored procedure for server-side data reduction which is not available for MySQL.
</para>

<para>Whatever database you use, in the end you need to provide all CSS archive tools
with the following configuration information
as elaborated in <xref linkend="ch_rdb_url_and_schema"/>:
</para>
<itemizedlist>
<listitem>URL</listitem>
<listitem>User name</listitem>
<listitem>Password</listitem>
<listitem>Schema
</listitem>
</itemizedlist>

<para>For the Archive Engine and Archive Config Tool,
you need to provide the user name and password
of an RDB account that has write access to the archive tables.
For the Data Browser or other tools that read data,
a read-only account is sufficient.
See <xref linkend="ch_preferences"/> for details on how to provide
these RDB settings for the archive plugins.
The command-line tools will also accept these parameters on the command-line.
</para>
</sect1>


<sect1>  <title>Archive Engine Configuration<indexterm><primary>Archive Engine</primary></indexterm></title>

<para>Each sample engine configuration identified by a name, for example
<quote>WaterSystem</quote>. Inside the RDB the configuration is actually
identified by a unique numeric ID, but most end user tools only see the
name of the configuration.
</para>

<sect2>  <title>Channel Groups</title>
<para>Each archive engine configuration is comprised of groups.
An engine configuration has at least one group, maybe more, and channels are
then added to these groups. Groups are not hierarchical: There are no sub-groups
within groups, only one list of groups.</para>

<para>Groups are primarily used to organize the configuration.
For example, a <quote>WaterSystem</quote> sample engine configuration might
have groups <quote>WestSector</quote>, <quote>MainBuilding</quote> etc. to hold
the channels for the respective section of the water system.
Note that this arrangement of channels into groups is <emphasis>not visible to end users of the data</emphasis>!
The separation of channels into groups inside the sample engine configuration is
mostly meant for the engineers who maintain the sample engine configuration,
grouping the channels by location along the machine, but associated front-end computer,
or by functionality.
</para>

<para>There is one functional aspects of groups: Archiving of all channels in a group
can be enabled or disabled based on one channel in the group.
When placing all channels of a power supply in a group, this feature can be used to
suppress archiving of noise while the power supply is off by using a channel
that indicates whether the power supply is on or off to enable the archive channel group.
</para>
</sect2>

<sect2 xml:id="sec_arch_channel">  <title>Channels</title>
<para>A channel in the archive system is basically the data provided by one Process Variable.
A channel is identified by its name, which has to be a valid PV name for the control system,
a PV that you can also read with other control system tools.
The samples stored for the channel include not only the value, for example a number,
but also the time stamp, status/severity and meta data like engineering units and display ranges.
The time stamp, status/severity and value are stored with each sample.
The meta data is only stored once at startup of the archive engine because the original
implementation for EPICS did not offer an efficient way to monitor for changes in the
meta data.
</para>

<para>When a channel sends a new value to the archive engine is somewhat outside of the
control of the archive engine. The software on the front end computer controls this.
For EPICS record, the <code>SCAN</code> field in combination with the <code>ADEL</code> field
of analog records determines when a new value is sent to the archive engine.</para>

<para>The meta data for a channel is similarly controlled by the front end device that
provides the data. For EPICS records, the <code>EGU</code>, <code>HOPR</code> and other fields
have to be used to configure these.</para>
</sect2>

<sect2>  <title>Duplicate Channels</title>
<para>The RDB configuration allows for multiple sample engines.
Each sample engine has one or more groups of channels, and each group has one or more channels.
A channel, however, <emphasis>can only be archived once</emphasis>. It is illegal to list a channel
in more than one group or under more than one sample engine.
</para>
</sect2>
</sect1>


<sect1>  <title>Sample Modes</title>
<para>The archive engine supports several sample modes, i.e. ways in which it decides what
samples should be written to the archive data store.
As just mentioned in <xref linkend="sec_arch_channel"/>, the front-end computer decides which
updates to send to the archive engine. In an ideal world, every such change would be meaningful
and there were infinite resources (CPU power, disk space, network bandwidth) to store every
change until eternity.
In reality, it is often better to store fewer samples.
</para>

<sect2>  <title>Monitored</title>
<para>In monitored mode, each received sample is written to the store. With a perfectly
configured data source, for example an EPICS <code>ADEL</code> that only passes
significant changes to the archive engine, this mode is ideal:
Significant changes in value are written to the archive, while noise in the signal
is suppressed to minimize wasted resources.
</para>
</sect2>

<sect2>  <title>Monitored With Threshold</title>
<para>This mode is also monitored, but adding another value change threshold filter.
Ideally, the front-end computer already performs the thresholding, so only significant
changes are sent over the network to the archive engine.
In some cases, however, this is not possible, and for those cases the archive engine
itself can check for changes in the value, writing only samples that differ from the
last written sample by at least some configurable margin.
</para>
</sect2>

<sect2>  <title>Scanned/Sampled</title>
<para>In scanned mode, the archive engine still receives each update from the data source,
but it only writes the most recent sample at periodic times, for example once every 5 minutes.
</para>

<para>This mode is a compromise. If a channel has no significant change for hours, why
should the uninteresting changes fill disk space every 5 minutes?
On the other hand, if an important even happens that produces a brief <quote>blip</quote>
in the data, the archived data is likely to miss it when only storing a value every 5 minutes.
</para>

<para>This mode was created for channels which do not have a good dead-band configuration,
where using the monitored mode would add too many samples to the archive.
Periodic sampling is clearly imperfect, but sometimes a workable compromise.
</para>
</sect2>
</sect1>


<sect1>  <title>Editing the Configuration</title>
<para>The configuration for all archive engines resides in the RDB,
which allows you to modify it in various ways.
Note, however, that running archive engines are not notified of
configuration changes in the RDB because there is currently no
convenient mechanism for them to learn about such changes.
You <emphasis>must manually re-start all affected archive engines</emphasis> after
modifying their configuration!
</para>

<sect2>  <title>SQL Manipulation</title>
<para>It is possible to modify an archive engine configuration
via direct SQL manipulation, for example from an SQL shell:
<programlisting>
SELECT * FROM smpl_eng;
INSERT INTO smpl_eng(name, descr, url)
  VALUES ('demo', 'Example Engine',
          'http://somehost:4812');
</programlisting>
This clearly requires some familiarity with the RDB table layout,
see <xref linkend="sec_archive_rdb_setup"/>.
For operations like renaming a channel or bulk changes this can
be the most convenient procedure.
</para>
</sect2>

<sect2>  <title>Archive Config Tool<indexterm><primary>Archive Config Tool</primary></indexterm></title>
<para>The <code>ArchiveConfigTool</code> can export existing archive engine configurations
from the RDB into an XML file format, or import such XML files into the RDB.
The XML file format is compatible with the one used by the Channel Archiver,
allowing the import of existing archive engine configurations.
</para>

<para>The <filename>xml</filename> directory in the plugin
<code>org.csstudio.archive.config.rdb</code> contains a commented
example configuration file.
</para>

<para>The ArchiveConfigTool offers command-line help similar to this:
<programlisting>-help                    : show help
-engine my_engine        : Engine Name
-config my_config.xml    : XML Engine config file
-export                  : export configuration as XML
-import                  : import configuration from XML
-delete_config           : Delete existing engine config
-description 'My Engine' : Engine Description
-host my.host.org        : Engine Host
-port 4812               : Engine Port
-replace_engine          : Replace existing engine config, or stop?
-steal_channels          : Steal channels from other engine
-rdb_url jdbc:...        : RDB URL
-rdb_user user           : RDB User
-rdb_password password   : RDB Password
-rdb_schema schema       : RDB schema (table prefix), ending in '.'
</programlisting>
</para>

<para>To export an existing engine configuration into an XML file, use
<programlisting>ArchiveConfigTool -engine my_engine -config my_config.xml -export</programlisting>
In addition, the RDB connection parameters might have to be supplied unless
they are built into the tool or provided via a <code>-pluginCustomization</code>
argument.
</para>

<para>To import a configuration from an XML file into the RDB, use
<programlisting>ArchiveConfigTool -engine my_engine -config my_config.xml -import\
-host my.host.org -port 4812</programlisting>
The host name specifies the host on which the engine is supposed to execute,
and the port number under which is runs its web server.
The configuration file could be the edited result of a previous export, or
have been created by other means.
</para>

<para>The archive config tool is cautious about disturbing existing configurations.
By default it will stop when there is already a configuration in the RDB for the
same sample engine name unless the <code>-replace_engine</code> option is provided,
in which case an existing configuration for that engine name will be deleted before
importing the XML file.
Similarly, the config tool will ignore channel names that are already handled by
a different engine configuration, unless the <code>-steal_channels</code> option
is provided to instruct the tool to move such channels from the archive engine that
previously handled the channels.
</para>
</sect2>
</sect1>


<sect1>  <title>Running Archive Engines</title>
<para>The <code>ArchiveEngine</code> is a headless RCP application that
reads a sample engine configuration, connects to the control system channels
listed in the configuration, and writes received samples to the archive data
store.
</para>

<para>It supports these command-line arguments:
<programlisting>-help                         : Display Help
-port 4812                    : HTTP server port
-engine demo_engine           : Engine config name
-data /home/fred/Workspace    : Eclipse workspace location
-pluginCustomization /path/to/mysettings.ini: Eclipse plugin defaults
</programlisting>
</para>

<para>The <code>-pluginCustomization</code> parameter can be used to provide
settings for the RDB connection, to configure the logging, and to provide
settings for access to the control system, for example EPICS Channel Access
network preferences.
</para>
<para>The <code>-engine</code> parameter selects the sample engine configuration.
In principle, that engine configuration already includes the URL of the
engine web server, but an additional <code>-port</code> parameter is required
for two reasons: First, this allows the engine to start a web server which
can be used to monitor engine operation as soon as possible, for example while
the engine it trying to connect to an RDB. Secondly, the engine will compare the
provided port number with the port number of the URL in its configuration.
This is means as a basic constistency check that helps avoid running archive engines
with the wrong configuration.
</para>

<sect2>  <title>Engine Web Server</title>
<para>Each sample engine has a built-in web server for status information
and basic remote control of the engine. When starting the engine on a host,
the port number for this HTTPD must be provided.
The sample engine URL configured in the RDB should match the format
<programlisting><![CDATA[http://<host>:<port>/main]]></programlisting>

The engine will compare the port number from the URL with the port
number provided as a command-line argument.
</para>

<para>The engine web server provides several web pages, mostly linked
from the <code>.../main</code> URL. Note that the engine only serves a blank
page at its root URL. For example, accessing <code>http://localhost:4813</code>
will result in an empty page. You have to start browsing at <code>http://localhost:4813/main</code>.
Starting at <code>.../main</code>, one can drill down to the status of groups and individual channels.
</para>

<para>A few engine web pages are <emphasis>not</emphasis> accessible by following web browser links
because they affect the engine operation. This is meant to prevent a web-crawling program to accidentally
stop the engine.
<variablelist> <title>Other Engine URLs</title>
  <varlistentry><term><filename><![CDATA[http://<host>:<port>/stop]]></filename></term>
  <listitem>Invoke this URL to stop the engine gracefully, i.e.
  to ask the engine to write a final <code>Archive_Off</code>
  sample to each channel, then quit.
  </listitem>
  </varlistentry>
  
  <varlistentry><term><filename><![CDATA[http://<host>:<port>/restart]]></filename></term>
  <listitem>Invoke this URL to trigger a running restart of the engine.
  The engine will stop sampling, read its configuration,
  then start again.
  Invoking this URL is required after changes to the configuration of
  an archive engine.
  </listitem>
  </varlistentry>

  <varlistentry><term><filename><![CDATA[http://<host>:<port>/reset]]></filename></term>
  <listitem>Invoke this URL to reset engine statistics,
  for example the average write time displayed on the
  main page of the engine.
  </listitem>
  </varlistentry>

  <varlistentry><term><filename><![CDATA[http://<host>:<port>/environment]]></filename></term>
  <listitem>Invoke this URL to display engine environment settings
  which might be useful when trying to debug a problem.
  </listitem>
  </varlistentry>
</variablelist>
</para>
</sect2>

</sect1>


<sect1> <title>Web-Based Archive Monitor and Editor</title>
<para>At the SNS, a JSP-based collection of reports can display
graphs of the archive system performance, for example: Which archive engine
wrote how many samples to the archive over the last hour?
It also includes a web-based editor for the alarm system configuration.
</para>
<para>This reporting package, however, is currently part of a bigger,
more SNS-specific reporting package. Contact Kay Kasemir if you
are interested in collaborating on a more portable version of
these reports.
</para>
</sect1>


<sect1> <title>Viewing Data in CSS</title>
<para>TODO</para>
</sect1>

</chapter>
